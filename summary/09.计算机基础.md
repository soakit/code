# 网络

## 1. 网络模型

OSI七层模型：

- 物理层—传输介质(材料，电压)
- 链路层—内网寻址(ARP, ICMP)
- 网络层—外网寻址(IP)
- 传输层—通信稳定性(TCP)
- 表现层—统一各个网络结构
- 会话层—记录状态
- 应用层—应用细节(http, ftp, smtp/pop3等)

五层模型：

- 物理层
- 链路层—ARP、硬件接口、RARP通信
- 网络层—ICMP、IP、IGMP
- 传输层—TCP/UDP
- 应用层—应用程序(http, ftp, smtp/pop3, dns等)

## 2. tcp与udp

tcp—可靠的，用于文件下载、聊天；

udp—不可靠，用于p2p下载、直播、DNS(包小，无需分包，丢包重发即可)

# 操作系统

## 1. 进程与线程

进程拥有独立空间、存储，同一个进程内的所有线程共享一套空间、代码。

线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

- 多进程
  - 成本高(慢)、进程间隔离(安全)、进程间通信麻烦、写代码简单，如php/node。

  - 最多为CPU核心的个数。

  - 普通程序不能”创建进程“，只有系统进程才行。

  - 多的进程是分裂出来的，分裂出来的执行的是一套代码，父子进程可以共享句柄。

    > 进程间通信：管道、共享内存、socket。
    >
    > 句柄：程序的操作权限。

- 多线程
  
  - 成本低(快)、线程要死一块死(不安全)、线程间通信容易、写代码复杂，如java/c。

## 2. 数据库类型

- 文件型：sqllite—简单，小

- 关系型：mysql、oracle—数据间有关联

  - mysql免费，占有率高(绝大多数应用)，容灾略差。

  - oracle收费，占有率不高(金融、医疗)，容灾性特别强。

    > 用磁盘镜像做容灾。

- 文档型：mongodb—存储异构数据，方便。

- NoSQL：没有复杂的关系，对性能有极高的要求。如redis, memcached, hypertable, bigtable。

## 3. 内存

- 栈区:

  栈中只存储方法中（不包括对象的成员变量）的**基础数据类型**和**引用数据类型地址**，对象都存放在堆区中，每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

- 堆区:

  存储的全部是**对象实例**，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。

- 方法区:

  又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的**类信息、常量、静态变量**、即时编译器**编译后的代码**等数据。。

- 常量池：

  常量池(constant pool)属于**方法区的一部分**，指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量(现在是存放在堆中)，多个相同的内容在常量池中只存放一份。

- 内存堆和栈的区别

  堆一般用户存储可变长度的数据，如字符串类型；而栈用于存储固定长度的数据，如整型int。堆的读写速度远不及栈，因为堆是程序在运行是动态分配内存，而栈在程序编译时便已经分配好内存，但栈的大小不如堆，所以常出现栈溢出而很少出现堆溢出。
  原文链接：https://blog.csdn.net/sinat_41721615/article/details/90543637

# 软件工程

## 1.  软件设计原则

- 开闭原则（Open Close Principle）

  对扩展开发 对修改关闭 就是在不影响原有功能的基础上进行扩展   

  实现方法：接口实现

- 依赖倒置原则（Dependence Inversion Principle） 

  抽象不依赖于细节，细节应该依赖抽象   实现方法：

  先抽象后细节 接口和抽象类

- 单一职责原则（SRP）

  一个类尽量承担一种职责 如果有多个职责可以通过接口拆分（一个类实现多个接口）

- 接口隔离原则（Interface Segregation Principle）

  设计接口的时候需多个专门的接口，而不是单一的总接口

- 迪米特法则（Law of Demeter）/最少知道原则（ The Least Knowledge Principle）

  一个对象应该对其他对象保持最少的了解，强调的是降低类与类之间的耦合

- 里氏代换原则（Liskov Substitution Principle）

  客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示：

  ![图1](https://i.imgur.com/r2LeEfi.jpeg)

  考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示：
  ![](https://i.imgur.com/jMdwifq.jpg)
  原文链接：https://blog.csdn.net/LoveLion/article/details/7540445

- 合成复用原则（Composite Reuse Principle）

  原则是尽量使用合成/聚合的方式，而不是使用继承。

# 设计模式

## 1. 观察者模式 vs 发布订阅模式

从表面上看：

- 观察者模式里，只有两个角色 —— 观察者 + 被观察者
- 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人Broker

往更深层次讲：

- 观察者和被观察者，是松耦合的关系
- 发布者和订阅者，则完全不存在耦合

从使用层面上讲：

- 观察者模式，多用于单个应用内部
- 发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件

>  **发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。通过第三者交流，也就是在消息队列里面，我们常说的经纪人Broker。**

## 2. 装饰器模式 vs 代理模式

**装饰器模式**强调的是增强自身，在被**装饰**之后你能够在被增强的类上使用增强后的功能。 增强后你还是你，只不过能力更强了而已；

**代理模式**强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。 **代理模式**是为了实现对象的控制，因为被**代理**的对象往往难以直接获得或者是其内部不想暴露出来。
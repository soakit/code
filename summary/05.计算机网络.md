#  网络协议

## 1. 计算机网络体系结构

在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。

## 2. 网络协议是什么？

在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。

## 3. 为什么要对网络协议分层？

- 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。
- 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。
- 易于实现和维护。
- 促进标准化工作。分开后，每层功能可以相对简单地被描述。

> 网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。

## 4. 四层协议，五层协议和七层协议

- TCP/IP是一个四层的体系结构，主要包括：应用层、传输层、网际层和网络接口层。
- 五层协议的体系结构主要包括：应用层、传输层、网络层，数据链路层和物理层。
- OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。

注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。

# TCP/IP 协议族

## 1. 应用层

应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

## 2. 传输层

传输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。

### 2.1 TCP与UDP

传输层主要使用一下两种协议

1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

|              | UDP                                        | TCP                                |
| ------------ | ------------------------------------------ | ---------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                           |
| 是否可靠     | 不可靠，不使用流量控制和拥塞控制           | 可靠传输，使用流量控制和拥塞控制   |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                   |
| 传输方式     | 面向报文                                   | 面向字节流                         |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节         |
| 场景         | 适用于实时应用(IP电话、视频会议、直播等)   | 适用于要求可靠传输的应用(文件传输) |

**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**

运行在TCP协议上的协议：

- HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
- HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
- FTP（File Transfer Protocol，文件传输协议），用于文件传输。
- POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
- TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
- SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

运行在UDP协议上的协议：

- BOOTP（Boot Protocol，启动协议），应用于无盘设备。
- NTP（Network Time Protocol，网络时间协议），用于网络同步。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

运行在TCP和UDP协议上：

- DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。

## 3. 网络层

网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

## 4. 数据链路层

数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

一般的web应用的通信传输流是这样的：

![img](https://pic3.zhimg.com/80/v2-fbc00b3f632f6f43a172f84c4f7b296e_1440w.jpg)



发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

## 5. 物理层

在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

# TCP/IP 协议族2

在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。



![img](https://pic3.zhimg.com/80/v2-b55b42fcf8f23a095bff280e2708caa2_1440w.jpg)



互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。

划重点：

TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为TCP/IP协议族

## 1. TCP的三次握手四次挥手

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。

TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。**通过三次握手建立一个链接，通过四次挥手来关闭一个连接。**

**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。**

## 2. TCP报文的头部结构

在了解TCP连接之前先来了解一下TCP报文的头部结构。



![img](https://pic2.zhimg.com/80/v2-2aa192d35fb785d6ff699035d060dc47_1440w.jpg)



上图中有几个字段需要重点介绍下：

（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

- ACK：确认序号有效。
- FIN：释放一个连接。
- PSH：接收方应该尽快将这个报文交给应用层。
- RST：重置连接。
- SYN：发起一个新连接。
- URG：紧急指针（urgent pointer）有效。

需要注意的是：

- 不要将确认序号ack与标志位中的ACK搞混了。
- 确认方ack=发起方seq+1，两端配对。

## 3. 三次握手

三次握手的本质是确认通信双方收发数据的能力

首先，我让信使运输一份信件给对方，**对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。**

于是他给我回信，**我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。**

然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次**，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。**

这，就是三次握手，这样说，你理解了吗？



![img](https://pic1.zhimg.com/80/v2-c2602875a99f219451bb5d9fe087812c_1440w.jpg)



- 第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。
- 第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。
- 第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

## 4. 四次挥手

四次挥手的目的是关闭一个连接



![img](https://picb.zhimg.com/80/v2-083462b035aeaa02bbf10f67ab78f51f_1440w.jpg)



比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
- 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。
- 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。

## 5. 常见面试题

### 5.1 为什么TCP连接的时候是3次？2次不可以吗？

​	因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数据(可以理解服务端已经连接成功)，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

​	如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

### 5.2 为什么TCP连接的时候是3次，关闭的时候却是4次？

​	因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

### 5.3 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

​	这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。

### 5.4 如果已经建立了连接，但是客户端突然出现故障了怎么办？

​	TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 5.5 什么是HTTP，HTTP 与 HTTPS 的区别

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

![img](https://picb.zhimg.com/80/v2-39da212dc75c95119a12f3c21a4af568_1440w.jpg)

参考链接：https://zhuanlan.zhihu.com/p/141396896

# http协议

请求：请求行 －  请求头 － 请求体

- 请求行

  请求方法、请求uri、协议版本。

- 请求头

  通用头(Cache-control, Date, Connection), Origin, Host, User-Agent, Referer, Cookie等。

- 请求体

  客户端请求内容。

返回：状态行 －  响应头 － 响应体

- 状态行

  协议版本、状态码

  1xx：指示信息-表示请求已接收，继续处理

  ​	101 切换协议

  2xx：成功-表示请求已被成功接收

  ​	200 请求成功

  ​	206 部分内容

  3xx：重定向-要完成请求必须进行更进一步的操作

  ​	301 永久重定向—浏览器不会再次请求老地址

  ​	302 临时重定向—浏览器下次还会请求老地址

  ​	304 重定向到缓存

  4xx：客户端错误-请求有语法错误或请求无法实现

  ​	400 客户端请求语法错误

  ​	401 未授权

  ​	403 服务器收到请求，但是拒绝提供服务

  ​	404 未找到对应资源

  5xx：服务器错误-服务器未能实现合法的请求

  ​	500 服务器发生错误

  ​	503 服务暂不可用

- 响应头

  通用头, Location, Server等。

- 响应体

  服务器返回内容。

## 1. http协议版本

- http1.0，每个连接只能发送一个请求(用connection: keep-alive解决)。

- http1.1，所有的连接默认都是持久连接(keep-alive)，解决了复用TCP的问题，减少TCP的三次握手开销。；管道机制(持久连接的前提下，请求一次性打包传输过去，响应一次性打包传递回来)；先进先出(FIFO)导致执行依赖上一个请求执行完成，易引发队头阻塞；连接数上限造成请求阻塞，我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

- http2.0，多路复用，同个域名只需要占用一个 TCP 连接，解决了请求阻塞的问题。一个连接里，客户端和服务端可同时发送多个请求或回应，且不用按照顺序一一对应；header压缩；服务器推送。

- http3.0，基于 UDP 协议的“QUIC”协议，让UDP可靠；UDP快速握手；集成TLS1.3加密功能；“完美”地解决了“队头阻塞”问题。

  参考链接：[HTTP/2 & HTTP/3 解决了什么问题（必问）](https://mp.weixin.qq.com/s?__biz=Mzg5NDEyMzA2NQ==&mid=2247484944&idx=1&sn=3a38485526fe1a9b2647a62c90da9275&chksm=c0252b46f752a250a473ee56ac70f361320b6784a694874fd9399e03ff4d72f1bf9d17d17a7a&mpshare=1&scene=1&srcid=&sharer_sharetime=1585563337385&sharer_shareid=1b3fec889f336f42cbf3a621a215dfa9#rd)
  
  https://juejin.im/post/6844903683277193223

### 1.1 http2头部压缩

HTTP/2头部通过HPACK算法进行压缩，这种算法通过服务端和客户端个字维护索引表来实现。索引表又分为静态表和动态表。

1. 伪头字段

   Header传输以二进制桢的方式进行，为了与HTTP1中Header区分，这些以冒号开头的字段被称为“伪头字段”。

2. 静态表

   静态表中定义了61个Header字段与Index，可以通过传输Index进而获取Header的字段与值，极大减少了报文大小。静态表中的字段和值固定，而且是只读的。

   **静态表部分值**

   | Index | Header Name | Header Valu |
   | ----- | ----------- | ----------- |
   | 1     | :authority  | xxx.org     |
   | 2     | :method     | GET         |
   | 3     | :method     | POST        |
   | 4     | :path       | /           |
   | 5     | :path       | /index.html |
   | 6     | :scheme     | http        |
   | 7     | :scheme     | https       |

3. 动态表

   动态表接在静态表之后，结构与静态表相同，可随时更新。下图中索引号62、63即为动态表字段。

   ![img](https://upload-images.jianshu.io/upload_images/15607805-93c50c530cbb4307.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

参考链接：https://www.jianshu.com/p/d3ed49462878

### 1.2 服务端推送

- 从HTTP/2开始，服务器除了相应客户端的请求之外，还可以向客户端额外推送资源，这些资源遵守同源协议，有自己独立的URL，可以被浏览器缓存，可以多页面共享；同时客户端还可以拒绝推送过来的资源
- 有了server push，客户端可以通过额外的http头部，列出需要服务器push 哪些资源
- 服务器可以提前向客户端推送需要的资源。

### 1.3 http升级后的规则

- 从HTTP/1.x到HTTP/2的过程中，仍然适用的优化规则
  - 减少DNS查询。DNS查询需要时间，没有resolved的域名会阻塞请求。
  - 减少TCP连接。HTTP/2只使用一个TCP连接。
  - 使用CDN。使用CDN分发资源可以减少延迟。
  - 减少HTTP跳转。特别是非同一域名的跳转，需要DNS，TCP，HTTP三种开销。
  - 消除不必要的请求数据。HTTP/2压缩了Header。
  - 压缩传输的数据。gzip压缩很高效。
  - 客户端缓存资源。缓存是必要的。
  - 消除不必要的资源。激进的提前获取资源对客户端和服务端都开销巨大。
- 因为HTTP/2而不一样的优化规则
  - 域名分片：大概意思就是我们把资源放在不同域名下，绕过浏览器HTTP连接数的限制。HTTP2.0不用了
  - 文件合并：在HTTP2.0中，我们要使用更小的模块，优化缓存策略（因为大文件的某一部分更改了，整个大文件就无法缓存了）
  - 内联资源：在HTTP2.0中直接使用server push。

## 2. http缓存

### 2.1 缓存的类别

> 强缓存

- Cache-Control: 值是max-age:缓存的**秒数**；如**Cache-Control: max-age=31536000**。
- Expires: 值是**过期时间**(GMT格式，精确到秒)；如**Last-Modified:Tue, 24 Feb 2019 08:01:04 GMT**。

> 协商缓存

- ETag/If-None-Match: hash串；如**Etag:“5d8c72a5edda8d6a:3239″、If-None-Match:“5d8c72a5edda8d6a:3239″**。

  - 浏览器请求，服务器返回200，同时**返回头**Etag。

  - 浏览器再次请求此*URL*时，浏览器会向服务器传送*If-None-Match*请求头，询问文件hash值是否改变。如果服务器端的资源没有变化，则返回304状态码，返回体为空。当服务器端代码发生改变时，则重新发出资源，返回和第一次请求时类似。

- Last-Modified/If-Modified-Since：最后修改时间(GMT格式，精确到秒)；如**Last-Modified:Tue, 24 Feb 2019 08:01:04 GMT、If-Modified-Since:Tue, 24 Feb 2019 08:01:04 GMT**。

  - 浏览器请求，服务器返回200，同时**返回头**Last-Modified(文件在服务端最后被修改的时间)

  - 浏览器再次请求此*URL*时，浏览器会向服务器传送*If-Modified-Since*请求头，询问该时间之后文件是否有被修改过。如果服务器端的资源没有变化，则返回304状态码，返回体为空。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。

  注：若*If-Modified-Since*时间比服务器当前时间*(*当前请求时间*request_time)*还晚，会认为是个非法请求。

### 2.2 缓存的优先级

- 强缓存优先于协商缓存

Cache-Control(http1.1) > Expires(http1.0) > ETag/If-None-Match > Last-Modified/If-Modified-Since